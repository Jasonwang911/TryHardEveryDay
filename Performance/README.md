# 前端性能优化 CRP（关键渲染路径）
url解析---DNS解析--TCP三次握手（建立客户端和服务端的链接通道）--发送HTTP请求--服务器处理和相应--TCP的四次挥手（关闭客户端和服务器的链接通道）--浏览器解析渲染


## 前端性能优化的回答方式
- 70% 的同学上来就说减少合并资源、减少请求、数据缓存这些优化手段；
- 15% 的同学会提到需要在 DevTools 下先看看首屏时间，围绕首屏来优化；
- 10%的同学会提到需要接入一个性能平台来看看现状，诊断一下；
- 而只有 5% 的同学会从前端性能体系来系统考虑性能优化。

## 关键指标
1. 白屏时间: DNS 查询，建立 TCP 连接，发送首个HTTP请求（如果使用HTTPS还要介入 TLS 的验证时间），返回HTML文档，HTML文档 Head 解析完毕。它的标准时间是 300ms  

2. 首屏时间=白屏时间+渲染时间,指从浏览器输入地址并回车后，到首屏内容渲染完毕的时间。这期间不需要滚动鼠标或者下拉页面，否则无效。

- 采用中位数，做正态分布，看分位值统计: 在对首屏时间进行数据分析和可视化展现时，经常用到的是 P50（50分位值）、P90（90分位值）、P99（99分位值）。它们是怎么得出的呢？以 P99 为例，我们是把所有首屏时间排序，得出排在第 99 位的首屏时间就是 P99
- 秒开率， 即 1s 内打开用户的占比。这个概念最早来自阿里巴巴，后来被业界普遍采用。

## 缓存
以 58 同城的列表页项目为例，在客户端请求阶段，DNS 查询时间大概是 385 ms，TCP 三次握手及 TLS 协商时间 436 ms，数据返回 412 ms。一个请求下来大约是 1233 ms，这还是强网（WIFI/4G）情况下。如果是弱网（3G/2G）情况，一个请求连接都需要 2s 。但使用缓存的话，几乎可以说是几毫秒内完成请求，对比非常明显。
## 前端性能监控平台  
提效： 
体验： 

### 一次完整页面请求所发生的事情
1. URL解析（DNS解析）
- 地址解析和编码
- HTST（安全处理）
- 缓存检查

2. DNS服务器的DNS解析（20ms-120ms） DNS基于UDP不进行三次捂手，但是有丢包的可能

3. TCP三次握手（建立客户端和服务端的链接通道），分段传输, 但是安全可靠
- 如果请求是HTTPS，还需要SSL协商 
- ip地址来进行寻址，需要排队等待，最多能同时发送6个http请求 
- tcp创建连接，用于传输
- 利用tcp传送数据（拆分成数据包，有序，并且可靠，丢包会重发）, 服务器会按照顺序来接收

4. 发送HTTP请求--服务器处理和响应
- 请求行
- 请求头
- 请求体

5. 服务器处理和响应
- 默认不会断开keep-alive为了下次传输数据时，可以服用上次创建的连接
- 状态码 301，302会进行重定向操作  服务器返回304回去查询浏览器缓存进行返回

6. TCP的四次挥手（关闭客户端和服务器的链接通道）

7. 浏览器解析渲染
- css不会阻塞页面渲染
- js阻塞页面渲染（js脚本添加defer或者async）

8. 整体流程的缓存  


#### http版本
1. http 0.9 没有请求头和相应头，只能传输纯问题本
2. http 1.0 提供了http的header，根据header的不同来出来不同的资源
3. http 1.1 默认开启了keep-alive链路复用，管线化，服务器处理多个请求头 （对头阻塞问题）
4. http 2.0 用同一个tcp链接来发送数据，一个域名一个tcp（多路复用），头部压缩，服务器可以主动推送数据到客户端
5. http 3.0 解决了在传输过程中的队头阻塞问题（丢包重发问题，不再使用tcp，而是使用了udp）


#### 浏览器的渲染流程
1. 构建DOM树
- 转化
- 令牌
- 词法分析
- DOM树构建

- link是发送一个http请求，每一个http请求都是单独线程去处理的，不管资源是否拉回来，主线程都会继续解析。所以DOM树都是优先于CSSOM树生成的。所以link要放在头部，以便尽量的早拉取回css。
- css的引入@import导入是同步的，资源没有拉回来之前是阻塞DOM树的解析的。
- style中的css是同html一起请求回来的，不会触发请求就一定不会浪费请求时间，只会影响html的解析。
- js默认都是阻塞的，并且是阻塞主线程。加载js并解析完js才会继续下面的dom树的解析。这也是js放在底部的原因。defer和async都不阻塞DOM树的加载
```
<script defer></script>  js加载完成后优先解析DOM （js需要依赖关系的话可以使用defer）
<script async></script>  js加载完成后优先执行js（使用async加载的js尽量不使用依赖）
```

优化项目： 
- 标签语义化
- 避免多级嵌套

2. CSSOM树
- 选择器层级（选择器的渲染层级是从右到左的）
- css预编译器的问题： less和sass的层级嵌套编译完成后会生成无畏的层级嵌套

3. Render-Tree渲染树：计算出在整个视口之内的准确的位置和大小（布局计算--回流），然后渲染在页面上（绘制）
- HTML和Style sheet都是阻碍页面渲染的东西
- 每一次页面渲染必然会引发一次回流和重绘。只改变背景颜色重绘 
- 重绘不一定会引发回流，回流一定会影响重绘。所以需要减少回流，减少dom的操作。
- 样式的集中改变


#### DNS解析过程
- 本地解析（递归过程）
客户端--浏览器缓存是否解析过--本地hosts文件--本地DNS解析器缓存--本地DNS服务器

- DNS服务器解析（迭代过程）
根域名服务器--顶级域名服务器--权威域名服务器--外网服务器

1. 减少DNS请求次数
一个网站有多个域名，从多个服务器返回资源。Source中可以查看所有的资源来源的服务器。负载会增加DNS请求次数。

2. DNS预获取：rel="dns-prefetch"
```
<link rel="dns-prefetch" href="//www.wangshen.top">
```
3. 减少HTTP请求次数和请求资源的大小
- 资源的合并压缩
- 字体图标
- Base64尽量不要乱用： 提高代码量来优化图片渲染速度
- Gzip（一般能压缩60%）
- 图片懒加载
- 数据延迟分批加载
- CND资源：地域式分布


#### 应用缓存： 缓存的一半是静态资源，数据需要手动缓存

判断有无缓存---判断有无强缓存---判断有无协商缓存

- 内存缓存： 读取速度快，存储东西少
- 硬盘缓存： 读取速度慢，存储东西多

1. 打开页面，地址栏输入地址： 先查找硬盘中有无匹配，没有会发送网络请求
2. 普通刷新（F5）: 此时内存缓存可用，会被优先使用


##### 强缓存  nginx配置
浏览器  ===    浏览器缓存  ====  服务器

数据的请求和缓存标识会同时返回
1. expires: 年月日    http1.0
2. cache-control: max-age=2592000 （30天） 优先级更高 http1.1

资源服务器更新后，我们在页面中把请求的资源加hash值。在webpack中进行配置。

##### 协商缓存  强缓存失效，客户端携带标识请求服务器，服务器返回304或者200
1. last-modified、if-modufued-since: 第一次访问资源，服务器返回自动验
只能以秒计时
2. eTag、if-none-match
e-tag不是文件hash，






