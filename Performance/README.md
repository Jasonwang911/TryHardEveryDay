# 前端性能优化 CRP（关键渲染路径）
url解析---DNS解析--TCP三次握手（建立客户端和服务端的链接通道）--发送HTTP请求--服务器处理和相应--TCP的四次挥手（关闭客户端和服务器的链接通道）--浏览器解析渲染

### 一次完整页面请求所发生的事情
1. URL解析（DNS解析）
- 地址解析和编码
- HTST（安全处理）
- 缓存检查

2. DNS服务器的DNS解析（20ms-120ms）

3. TCP三次握手（建立客户端和服务端的链接通道）

4. 发送HTTP请求--服务器处理和相应

5. 服务器处理和相应

6. TCP的四次挥手（关闭客户端和服务器的链接通道）

7. 浏览器解析渲染


8. 整体流程的缓存  


#### 浏览器的渲染流程
1. 构建DOM树
- 转化
- 令牌
- 词法分析
- DOM树构建

- link是发送一个http请求，每一个http请求都是单独线程去处理的，不管资源是否拉回来，主线程都会继续解析。所以DOM树都是优先于CSSOM树生成的。所以link要放在头部，以便尽量的早拉取会css。
- css的引入@import导入是同步的，资源没有拉回来之前是阻塞DOM树的解析的。
- style中的css是同html一起请求回来的，不会触发请求就一定不会浪费请求时间，只会影响html的解析。
- js默认都是阻塞的，并且是阻塞主线程。加载js并解析完js才会继续下面的dom树的解析。这也是js放在底部的原因。defer和async都不阻塞DOM树的加载
```
<script defer></script>  js加载完成后优先解析DOM （js需要依赖关系的话可以使用defer）
<script async></script>  js加载完成后优先执行js（使用async加载的js尽量不使用依赖）
```

优化项目： 
- 标签语义化
- 避免多级嵌套

2. CSSOM树
- 选择器层级（选择器的渲染层级是从右到左的）
- css预编译器的问题： less和sass的层级嵌套编译完成后会生成无畏的层级嵌套

3. Render-Tree渲染树：计算出在整个视口之内的准确的位置和大小（布局计算--回流），然后渲染在页面上（绘制）
- HTML和Style sheet都是阻碍页面渲染的东西
- 每一次页面渲染必然会引发一次回流和重绘。只改变背景颜色重绘 
- 重绘不一定会引发回流，回流一定会影响重绘。所以需要减少回流，减少dom的操作。
- 样式的集中改变


#### DNS解析过程
- 本地机械（递归过程）
客户端--浏览器缓存是否解析过--本地hosts文件--本地DNS解析器缓存--本地DNS服务器

- DNS服务器解析（迭代过程）
根域名服务器--顶级域名服务器--权威域名服务器--外网服务器

1. 减少DNS请求次数
一个网站有多个域名，从多个服务器返回资源。Source中可以查看所有的资源来源的服务器。负载会增加DNS请求次数。

2. DNS预获取：rel="dns-prefetch"
```
<link rel="dns-prefetch" href="//www.wangshen.top">
```
3. 减少HTTP请求次数和请求资源的大小
- 资源的合并压缩
- 字体图标
- Base64尽量不要乱用： 提高代码量来优化图片渲染速度
- Gzip（一般能压缩60%）
- 图片懒加载
- 数据延迟分批加载
- CND资源：地域式分布


#### 应用缓存： 缓存的一半是静态资源，数据需要手动缓存

判断有无缓存---判断有无强缓存---判断有无协商缓存

- 内存缓存： 读取速度快，存储东西少
- 硬盘缓存： 读取速度慢，存储东西多

1. 打开页面，地址栏输入地址： 先查找硬盘中有无匹配，没有会发送网络请求
2. 普通刷新（F5）: 此时内存缓存可用，会被优先使用


##### 强缓存  nginx配置
浏览器  ===    浏览器缓存  ====  服务器

数据的请求和缓存标识会同时返回
1. expires: 年月日    http1.0
2. cache-control: max-age=2592000 （30天） 优先级更高 http1.1

资源服务器更新后，我们在页面中把请求的资源加hash值。在webpack中进行配置。

##### 协商缓存  强缓存失效，客户端携带标识请求服务器，服务器返回304或者200
1. last-modified、if-modufued-since: 第一次访问资源，服务器返回自动验
只能以秒计时
2. eTag、if-none-match
e-tag不是文件hash，



